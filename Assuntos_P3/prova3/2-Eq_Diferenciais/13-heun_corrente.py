import numpy as np
import matplotlib.pyplot as plt


def euler(f, x0, y0, h, n):
    vals = []
    for k in range(n):
        y0 += h*f(x0, y0)
        x0 += h
        vals.append([x0, y0])
    return vals


# b = 1
def euler_mid(f, x0, y0, h, n):
    vals = []
    for _ in range(n):
        m1 = f(x0, y0)
        m2 = f(x0 + h / 2, y0 + (h/2) * m1)
        y0 += h*m2
        x0 += h
        vals.append([x0, y0])
    return vals



# b = 2/3
# def ralston(f, x0, y0, h, n):
#     vals = []
#     for _ in range(n):
#         m1 = f(x0, y0)
#         m2 = f(x0 + 0.75*h, y0 + 0.75*h*m1)
#         y0 = h*(m1 + 2*m2)/3
#         x0 += h
#         vals.append([x0, y0])
#     return vals


# padrao = euler_mid
def rk2(f, x0, y0, h, n, b=1.0):
    # b = 1 => metodo = euler_mid
    # b = 1/2 => metodo = heun
    # b = 2/3 => metodo = ralston
    vals = []
    a = 1-b
    p = 1/(2*b)
    q = p
    for _ in range(n):
        m1 = f(x0, y0)
        m2 = f(x0 + p*h, y0 + q*h*m1)
        y0 += (a*m1 + b*m2)*h
        x0 += h
        vals.append([x0, y0])
    return vals

# b = 1/2
def heun(f, x0, y0, h, n):
    vals = []
    for _ in range(n):
        m1 = f(x0, y0)
        m2 = f(x0 + h, y0 + h*m1)
        y0 += h*(m1+m2)/2
        x0 += h
        vals.append([x0, y0])
    return vals

# b = 1/2
def heun_h_variavel(f, x0, y0, n, b, t_values):
    vals = []
    a = 1-b
    p = 1/(2*b)
    q = p
    for i in range(n):
        if i == 0:
            h = t_values[0] - x0
        else:
            h = t_values[i] - t_values[i-1]
        m1 = f(x0, y0)
        m2 = f(x0 + p*h, y0 + q*h*m1)
        y0 += (a*m1 + b*m2)*h
        x0 += h
        vals.append([x0, y0])
    return vals

def rk2_h_variavel(f, x0, y0, n, b, x_values):
    # b = 1 => metodo = euler_mid
    # b = 1/2 => metodo = heun
    # b = 2/3 => metodo = ralston
    vals = []
    a = 1-b
    p = 1/(2*b)
    q = p
    for i in range(n):
        if i == 0:
            h = x_values[0] - x0
        else:
            h = x_values[i] - x_values[i-1]
        m1 = f(x0, y0)
        m2 = f(x0 + p*h, y0 + q*h*m1)
        y0 += (a*m1 + b*m2)*h
        x0 += h
        vals.append([x0, y0])
    return vals


def diff(a, b):
    return sum((ai - bi)**2 for ai, bi in zip(a, b))


def f(x, y):
    return -y/np.sqrt(9**2-y**2)



def g(t, i):
    c = 0.3383
    r = 1.4084
    l = 1.6413

    # considerando a funÃ§Ã£o e(t) = e^(-e_value*pi*t)*sin(2*t-pi)
    # se e^(-0.0619*pi*t) => e_value = 0.0619
    e_value = 0.0526

    def e(t):
        return np.exp(-e_value*np.pi*t)*np.sin(2*t-np.pi)

    def e_(t):
        return np.exp(-e_value*np.pi*t)*(2*np.cos(np.pi-2*t)+e_value*np.pi*np.sin(np.pi-2*t))

    def e__(t):
        return np.exp(-e_value*np.pi*t)*((4-pow(e_value, 2)*pow(np.pi, 2))*np.sin(np.pi-2*t)-4*e_value*np.pi*np.cos(np.pi-2*t))

    return c*e__(t) + (1/r)*e_(t) + (1/l)*e(t)


if __name__ == '__main__':

    x0, y0 = 0,0
    h = 0.1201
    n = 150
    b = 1/2
    # x_values = [0.0119, 0.1754, 0.2308, 0.3535, 0.4767, 0.5694, 0.621, 0.7525, 0.8692, 0.9152, 1.0617, 1.1448, 1.2848, 1.3853, 1.4848, 1.547, 1.6447, 1.739, 1.8595, 1.9671, 2.0233, 2.1479, 2.2786, 2.3408, 2.4652, 2.579, 2.6564, 2.7882, 2.8469, 2.9882, 3.0379, 3.119, 3.2157, 3.3555, 3.4285, 3.5634, 3.6231, 3.7372, 3.8676, 3.9686, 4.0121, 4.1569, 4.226, 4.3808, 4.4592, 4.5858, 4.6596, 4.7646, 4.8576, 4.9871, 5.0798, 5.186, 5.2313, 5.3305, 5.4847, 5.5172, 5.6604, 5.7114, 5.8386, 5.9828, 6.0553, 6.1237, 6.2478, 6.3542, 6.4291, 6.5259, 6.6785, 6.7872, 6.8824, 6.9222, 7.043, 7.1115, 7.2889, 7.3118, 7.4683, 7.5752, 7.6784, 7.7381, 7.8537, 7.9216, 8.0482, 8.1262, 8.2349, 8.3245, 8.4343, 8.5837, 8.6483, 8.7553, 8.8328, 8.971, 9.0145, 9.1164, 9.2437, 9.3108, 9.4542, 9.5399, 9.6294, 9.7803, 9.8754, 9.9684, 10.0862, 10.124, 10.2695, 10.3799, 10.4382, 10.5378, 10.6535, 10.7239, 10.8636, 10.9887, 11.0588, 11.1367, 11.243, 11.3122, 11.4389, 11.519, 11.6806, 11.7899, 11.8487, 11.9862, 12.0768, 12.1104, 12.2647, 12.3483, 12.4509, 12.5702, 12.6823, 12.7467, 12.8569, 12.9393, 13.0641, 13.1348, 13.2596, 13.3894, 13.4104, 13.5312, 13.6498, 13.7383, 13.8885, 13.9245, 14.0746, 14.1167, 14.2464, 14.3127, 14.4841, 14.5201, 14.6288, 14.7431, 14.8197, 14.9437]
    t_values = [0.0576, 0.1835, 0.237, 0.3586, 0.4545, 0.5383, 0.646, 0.7324, 0.8746, 0.9658, 1.0554, 1.1761, 1.2459, 1.3648, 1.4685, 1.5764, 1.6645, 1.7146, 1.89, 1.9706, 2.0225, 2.1323, 2.2627, 2.3711, 2.4293, 2.5827, 2.6729, 2.7714, 2.844, 2.9188, 3.0373, 3.1228, 3.2713, 3.3877, 3.4751, 3.5723, 3.6288, 3.7226, 3.8271, 3.9113, 4.0794, 4.1801, 4.2353, 4.381, 4.4242, 4.5669, 4.6145, 4.7606, 4.8819, 4.9644, 5.0845, 5.1161, 5.2507, 5.3359, 5.4755, 5.563, 5.6799, 5.7277, 5.8186, 5.9789, 6.0724, 6.1699, 6.2701, 6.3386, 6.4628, 6.5592, 6.6728, 6.7699, 6.8619, 6.9497, 7.0337, 7.1755, 7.2489, 7.3234, 7.4704, 7.5767, 7.6289, 7.7826, 7.8126, 7.9387, 8.0572, 8.1459, 8.2554, 8.3151, 8.4255, 8.5687, 8.6444, 8.7452, 8.8647, 8.9185, 9.0355, 9.163, 9.2396, 9.3871, 9.4389, 9.5694, 9.6135, 9.7466, 9.8176, 9.9891, 10.0676, 10.1394, 10.2822, 10.3315, 10.4317, 10.5238, 10.6428, 10.7606, 10.8403, 10.9218, 11.0513, 11.1766, 11.2805, 11.3878, 11.439, 11.5512, 11.6155, 11.7863, 11.8704, 11.9773, 12.0314, 12.1514, 12.2126, 12.3517, 12.4349, 12.5359, 12.6449, 12.7614, 12.8605, 12.9258, 13.0833, 13.162, 13.2418, 13.3697, 13.4468, 13.5244, 13.6669, 13.7209, 13.8836, 13.9852, 14.086, 14.1318, 14.2601, 14.3818, 14.475, 14.5574, 14.664, 14.7111, 14.8639, 14.953]

    # metodo1 = euler(f, x0, y0, h, n)
    # metodo2 = euler_mid(f, x0, y0, h, n)
    # metodo3 = heun(f, x0, y0, h, n)
    # metodo4 = ralston(f, x0, y0, h, n)
    # metodo5 = rk2(g, x0, y0, h, n, b)
    # metodo5 = rk2(g, x0, y0, h, n, b)
    metodo6 = heun_h_variavel(g, x0, y0, n, b, t_values)

    indice = [i for i in range(n)]
    lista_y = metodo6

    # for i, xi, yi in zip(indice, lista_x, lista_y):
    #     # print(f'x{i} = {xi} => y{i} = {yi}')
    #     print(f'{yi},', end='')

    for i in lista_y:
        print(f'{i[1]},', end='')

    # plt.scatter(lista_x, lista_y)

    # plt.savefig('edo.png')